<!-- DoAttack2 macro -->
<!-- Returns: 4 -->
<!-- 1 : Result of attack roll.  0 = fumble, 1 = miss, 2 = hit, 3 = crit -->
<!-- 2 : Actual attack roll 1-20 -->
<!-- 3 : Rolled damage -->
<!-- 4 : Total damage of rolled + modifiers -->
<!-- 5 : String of multiple attack rolls if rerollAttack = 1 -->
<!-- Parameters: 12 -->
<!-- 12 : Integer boolean to reroll attack 1 time and use higher value -->
<!-- This macro takes in a single target and information to make a roll to see if the target is hit -->
<!-- Apply damage/effects to target on hit/miss and return values depending on result -->

[h:targetName      = json.get(macro.args, 0)]
[h:targetDefense   = json.get(macro.args, 1)]
[h:atkMod          = json.get(macro.args, 2)]
[h:damRoll         = json.get(macro.args, 3)]
[h:critDamRoll     = json.get(macro.args, 4)]
[h:damMod          = json.get(macro.args, 5)]
[h:autoHit         = json.get(macro.args, 6)]
[h:missDamageRoll  = json.get(macro.args, 7)]  <!-- damage to roll on a miss, will not apply to minions -->
[h:targetStateJson = json.get(macro.args, 8)]  <!-- Json holding states to be applied to target with this power -->
[h:selfStateJson   = json.get(macro.args, 9)]  <!-- Json holding states to be applied to self with this power -->
[h:markJson        = json.get(macro.args, 10)] <!-- Json array telling when to apply Mark to target -->
[h:rerollAttack    = json.get(macro.args, 11)]

[h:propTargetStatesJson = getProperty("TargetStates")]
[h:propSelfStatesJson   = getProperty("SelfStates")]
[h:propMarkJson         = getProperty("TargetMark")]
[h:selfName             = getName()]
[h:switchToken(targetName)]
[h:def=getProperty(targetDefense)]
[h:atkRoll=eval("1d20")]
<!-- Reroll the attack roll once, take highest -->
[h:atkRolls=""]
[h,if(rerollAttack): atkRoll2=eval("1d20")]
[h,if(rerollAttack): atkRolls=strformat("(%d,%d)",atkRoll,atkRoll2)]
[h,if(rerollAttack): atkRoll=if(atkRoll2>atkRoll,atkRoll2,atkRoll)]

[h,if(atkRoll==20 && autoHit!=1): damage=eval(string(critDamRoll)); damage=eval(string(damRoll))]
[h:totalDamage=damage+eval(string(damMod))]
[h,if(totalDamage<1):totalDamage=1]
[h,if(atkRoll+eval(atkMod)>=def):  resu=2; resu=1]
[h,if(atkRoll==20): resu=3]
[h,if(atkRoll==1):  resu=0]
[h,if(autoHit):     resu=2]

<!-- set damage to missDamageRoll if attack will not hit -->
[h,if(resu<=1 && missDamageRoll!=-1 && MaxHP>1): applyMissDam=1;applyMissDam=0]
[h,if(applyMissDam && missDamageRoll!=-2): totalDamage = eval(string(missDamageRoll))]
[h,if(applyMissDam && missDamageRoll==-2): totalDamage = floor(totalDamage/2)] 

<!-- apply damage to target if needed -->
[h,if(resu>1 || applyMissDam),code:
{
  [h,if(TempHP>=totalDamage), code:
  {
    [h: TempHP = TempHP - totalDamage]
  };{
    [h: totalDamage = totalDamage - TempHP]
    [h: TempHP = 0]
    [h: CurrentHP = CurrentHP - totalDamage]
    [h,if(CurrentHP<=floor(MaxHP/2) && CurrentHP+totalDamage>floor(MaxHP/2)): state.Bloodied=1]
  }]
  [h,if(CurrentHP<=0 && isPC()),code:
  {
    [h:state.Unconscious=1]
    [h:state.Prone=1]
    [h:CurrentHP = 0]
  };{}]
  [h,if(CurrentHP<=0 && isNPC()),code:
  {
    [h:setAllStates(0)]
    [h:state.Dead=1]
  };{}]
};{}]

[h:switchToken(selfName)]

<!-- apply states to Target -->
[h:emptyJson="[]"]
[h,SWITCH(resu):
  case 0: setJsonStates(json.merge(if(length(json.get(propTargetStatesJson,0))>0,json.get(propTargetStatesJson,0),emptyJson),if(length(json.get(targetStateJson,0))>0,json.get(targetStateJson,0),emptyJson)),targetName);
  case 1: setJsonStates(json.merge(if(length(json.get(propTargetStatesJson,0))>0,json.get(propTargetStatesJson,0),emptyJson),if(length(json.get(targetStateJson,0))>0,json.get(targetStateJson,0),emptyJson)),targetName);
  case 2: setJsonStates(json.merge(if(length(json.get(propTargetStatesJson,1))>0,json.get(propTargetStatesJson,1),emptyJson),if(length(json.get(targetStateJson,1))>0,json.get(targetStateJson,1),emptyJson)),targetName);
  case 3: setJsonStates(json.merge(if(length(json.get(propTargetStatesJson,2))>0,json.get(propTargetStatesJson,2),emptyJson),if(length(json.get(targetStateJson,2))>0,json.get(targetStateJson,2),emptyJson)),targetName);
]
[h:setJsonStates(json.merge(if(length(json.get(propTargetStatesJson,3))>0,json.get(propTargetStatesJson,3),emptyJson),if(length(json.get(targetStateJson,3))>0,json.get(targetStateJson,3),emptyJson)),targetName)]

<!-- apply states to Self -->
[h:emptyJson="[]"]
[h,SWITCH(resu):
  case 0: setJsonStates(json.merge(if(length(json.get(propSelfStatesJson,0))>0,json.get(propSelfStatesJson,0),emptyJson),if(length(json.get(selfStateJson,0))>0,json.get(selfStateJson,0),emptyJson)),selfName);
  case 1: setJsonStates(json.merge(if(length(json.get(propSelfStatesJson,0))>0,json.get(propSelfStatesJson,0),emptyJson),if(length(json.get(selfStateJson,0))>0,json.get(selfStateJson,0),emptyJson)),selfName);
  case 2: setJsonStates(json.merge(if(length(json.get(propSelfStatesJson,1))>0,json.get(propSelfStatesJson,1),emptyJson),if(length(json.get(selfStateJson,1))>0,json.get(selfStateJson,1),emptyJson)),selfName);
  case 3: setJsonStates(json.merge(if(length(json.get(propSelfStatesJson,2))>0,json.get(propSelfStatesJson,2),emptyJson),if(length(json.get(selfStateJson,2))>0,json.get(selfStateJson,2),emptyJson)),selfName);
]
[h:setJsonStates(json.merge(if(length(json.get(propSelfStatesJson,3))>0,json.get(propSelfStatesJson,3),emptyJson),if(length(json.get(selfStateJson,3))>0,json.get(selfStateJson,3),emptyJson)),selfName)]

<!-- apply Marks to target -->
[h:useMarkJson=json.unique(json.merge(propMarkJson,markJson))]
[h,if(json.indexOf(useMarkJson,resu-1)!=-1 || json.indexOf(useMarkJson,3)!=-1): tmpBool=1;tmpBool=0]
[h,if(json.length(useMarkJson)>0 && tmpBool): evalMacro('[h,macro("ApplyMark@"+UseLib): json.append("[]",useMarkJson,targetName)]')]

[h:macro.return = json.append("[]",resu,atkRoll,damage,totalDamage,atkRolls)]